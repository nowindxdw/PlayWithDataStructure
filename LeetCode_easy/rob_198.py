# -*- coding: utf-8 -*-
'''
动态规划的的四个解题步骤是：
1.定义子问题
2.写出子问题的递推关系
3.确定 DP 数组的计算顺序
4.空间优化（可选）

- 定义子问题的原则：
1原问题要能由子问题表示。
2一个子问题的解要能通过其他子问题的解求出


2写出子问题的递推关系
这一步是求解动态规划问题最关键的一步。然而，这一步也是最无法在代码中体现出来的一步

  k个房子中最后一个房子是H(k-1)如果不偷这个房子，那么问题就变成在前 K-1个房子中偷到最大的金额，也就是子问题 。
  如果偷这个房子，那么前一个房子 H(k-2)显然不能偷，其他房子不受影响。那么问题就变成在前 k-2个房子中偷到的最大的金额。
  两种情况中，选择金额较大的一种结果。
   f(k) = max(f(k-1),f(k-2)+H(k-1))
   当  k=0时，没有房子，所以f(0)=0 。
    当 k-1 时，只有一个房子，偷这个房子即可，所以f(1)=H(0)

3：确定 DP 数组的计算顺序
在确定了子问题的递推关系之后，下一步就是依次计算出这些子问题了。
在很多教程中都会写，动态规划有两种计算顺序，一种是自顶向下的、使用备忘录的递归方法，
一种是自底向上的、使用 DP 数组的循环方法。
不过在普通的动态规划题目中，99% 的情况我们用循环方法就很好解决


'''


class Solution():
    def rob(self,nums):
        if len(nums) == 0 :
            return 0
        #子问题：
        #f(k) = 偷[0..k) 房间中的最大金额
        #f(0) = 0
        # f(1) = nums[0]
        # f(k) = max(rob(k - 1), nums[k - 1] + rob(k - 2))


        N = len(nums)
        dp = [0 for i in range(N+1)]
        dp[0] = 0
        dp[1] = nums[0]
        for k in range(2,N+1) :
            print("k=%s"%k)
            # 套用子问题的递推关系
            dp[k] = max(dp[k - 1], nums[k - 1] + dp[k - 2])

            print("dp=%s" % dp)
        return dp[N]


if __name__ == "__main__":
    input = [1,2,3,1]
    solution=Solution()
    result = solution.rob(input)
    print(result)
